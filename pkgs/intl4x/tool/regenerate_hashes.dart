import 'dart:io';

import 'package:crypto/crypto.dart';
import 'package:intl4x/src/hook_helpers/version.dart';
import 'package:native_assets_cli/native_assets_cli.dart';

final httpClient = HttpClient();

Future<void> main(List<String> args) async {
  print('Checking hashes for $version');
  final fileHashes = <(String, Architecture, String), String>{};
  final datagenHashes = <(String, Architecture), String>{};
  final file = File.fromUri(Directory.systemTemp.uri.resolve('lib'));
  await file.create();
  for (final os in ['linux', 'windows', 'fuchsia', 'android', 'macOS', 'iOS']) {
    for (final architecture in Architecture.values) {
      final target = OS.values
          .firstWhere((value) => value.toString() == os.toLowerCase())
          .executableFileName('${os}_$architecture-datagen');
      final datagenHash = await getHash(target, file);
      if (datagenHash != null) {
        datagenHashes[(os, architecture)] = datagenHash;
      }
      for (final libraryType in ['dynamic', 'static']) {
        final target = '${os}_${architecture}_$libraryType';
        final fileHash = await getHash(target, file);
        if (fileHash != null) {
          fileHashes[(os, architecture, libraryType)] = fileHash;
        }
      }
    }
  }
  httpClient.close(force: true);

  await File('lib/src/hook_helpers/hashes.dart').writeAsString('''
// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// THIS FILE IS AUTOGENERATED BY `tool/regenerate_hashes.dart`. TO UPDATE, RUN
//
//    dart --enable-experiment=native-assets tool/regenerate_hashes.dart
//

import 'package:native_assets_cli/native_assets_cli.dart';

const fileHashes = <(OS, Architecture, String), String>{
${fileHashes.map((key, value) => MapEntry(
                ('OS.${key.$1}', 'Architecture.${key.$2}', "'${key.$3}'"),
                "'$value'",
              )).entries.map(
            (e) => '  ${e.key}:\n      ${e.value}',
          ).join(',\n')}
};

const datagenHashes = <(OS, Architecture), String>{
${datagenHashes.map((key, value) => MapEntry(
                ('OS.${key.$1}', 'Architecture.${key.$2}'),
                "'$value'",
              )).entries.map(
            (e) => '  ${e.key}:\n      ${e.value}',
          ).join(',\n')}
};
''');
}

Future<String?> getHash(String target, File dynamicLibrary) async {
  print('Checking hash for $target');
  final success = await _fetchLibrary(target, httpClient, dynamicLibrary);
  if (success) {
    final bytes = await dynamicLibrary.readAsBytes();
    final fileHash = sha256.convert(bytes).toString();
    print('Hash is $fileHash');
    return fileHash;
  } else {
    print('Could not fetch library');
    return null;
  }
}

Future<bool> _fetchLibrary(
    String target, HttpClient httpClient, File dynamicLibrary) async {
  final uri = Uri.parse(
      'https://github.com/dart-lang/i18n/releases/download/$version/$target');
  print('Fetch file from $uri');
  final request = await httpClient.getUrl(uri);
  final response = await request.close();
  if (response.statusCode != 200) {
    print('File not found at $uri');
    return false;
  }
  await response.pipe(dynamicLibrary.openWrite());
  return true;
}
